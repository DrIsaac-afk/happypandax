{
	"version": 3,
	"file": "D:/Code/happypandax/webclient/happypanda/static/__javascript__/client.mod.js",
	"sources": [
		"D:/Code/happypandax/webclient/happypanda/static/client.py"
	],
	"sourcesContent": [
		"__pragma__('alias', 'S', '$')  # JQuery\n\nimport utils\n\ndebug = True\n\n\nclass Base:\n\n    def __init__(self, url=\"\"):\n        self.url = utils.URLManipulator(url)\n        self._flashes = []\n\n    def main(self):\n\n        if self.url:\n\n            self.log(\"setting active menu item\")\n\n            def each_d(index):\n\n                aurl = S(this).find('a').attr(\"href\")\n                if aurl == self.url.path():\n                    S(this).addClass(\"active\")\n                    S(this).find('a').append('<span class=\"sr-only\">(current)</span>')\n\n            S(\"#nav-collapse li\").each(each_d)\n\n    def log(self, msg):\n        if debug:\n            print(msg)\n\n    def flash(self, msg, flash_type='danger', strong=\"\"):\n        \"\"\"\n        - info\n        - sucess\n        - warning\n        - danger\n        \"\"\"\n\n        lbl = 'alert-' + flash_type\n        obj = self.compile(\n            \"#global-flash-t\",\n            \"#global-flash\",\n            prepend=True,\n            alert=lbl,\n            strong=strong,\n            msg=msg)\n        obj.delay(8000).fadeOut(500)\n\n    def get_label(self, label_type):\n        \"\"\"\n        - default\n        - primary\n        - success\n        - info\n        - warning\n        - danger\n        \"\"\"\n        return 'label-' + label_type\n\n    __pragma__('kwargs')\n\n    def compile(\n            self,\n            source_el,\n            target_el,\n            after=None,\n            before=None,\n            append=None,\n            prepend=None,\n            **data):\n        \"\"\"\n        Compile template element\n        Set after, before, append or prepend to True to specify where to insert html.\n\n        Returns inserted element\n        \"\"\"\n        src = S(source_el).html()\n        if not src:\n            console.error(\"{} could not be found, compilation aborted\".format(source_el))\n            return\n        tmpl = Handlebars.compile(src)\n        if after:\n            return S(tmpl(data)).insertAfter(target_el)\n        elif before:\n            return S(tmpl(data)).insertBefore(target_el)\n        elif append:\n            return S(tmpl(data)).appendTo(target_el)\n        elif prepend:\n            return S(tmpl(data)).prependTo(target_el)\n        else:\n            return S(target_el).html(tmpl(data))\n    __pragma__('nokwargs')\n\n    def flash_error(self, error, flash_type='danger'):\n        if error:\n            self.flash(error['msg'], flash_type, error['code'])\n\n\nclass ServerMsg:\n    msg_id = 0\n\n    def __init__(self, data, callback=None, func_name=None):\n        ServerMsg.msg_id += 1\n        self.id = self.msg_id\n        self.data = data\n        self.callback = callback\n        self.func_name = func_name\n\n\nclass Client(Base):\n\n    polling = False\n\n    __pragma__('kwargs')\n    def __init__(self, session=\"\", namespace=\"\", new=False):\n        self.socket_url = location.protocol+'//'+location.hostname+':'+location.port+namespace\n        self.socket = io(self.socket_url, {'forceNew':new, 'transports': ['websocket']})\n        self.socket.on(\"command\", self.on_command)\n        self.socket.on(\"server_call\", self.on_server_call)\n        self.socket.on(\"exception\", self.on_error)\n\n        self.commands = {\n            'connect': 1,\n            'reconnect': 2,\n            'disconnect': 3,\n            'status': 4,\n            'handshake': 5\n        }\n\n        self.namespace = namespace\n        self.session = session\n        self.name = \"webclient\"\n        self._connection_status = True\n        self._disconnected_once = False\n        self._response_cb = {}\n        self._last_msg = None\n        self._msg_queue = []\n        self._cmd_status = {}\n        self._cmd_status_c = 0\n\n        if not self.polling:\n            utils.poll_func(self.connection, 3000000, 15000)\n            Client.polling = True\n    __pragma__('nokwargs')\n\n    def connection(self):\n        self.send_command(self.commands['status'])\n        if not self._connection_status:\n            self.flash(\"Trying to establish server connection...\", 'info')\n            self.send_command(self.commands['connect'])\n        return False\n\n    def send_command(self, cmd):\n        assert cmd in self.commands.values(), \"Not a valid command\"\n        self.socket.emit(\"command\", {'command': cmd})\n\n    def on_command(self, msg):\n\n        self._connection_status = msg['status']\n        st_txt = \"unknown\"\n        st_label = self.get_label(\"default\")\n        if self._connection_status:\n            if self._disconnected_once:\n                self._disconnected_once = False\n                self.flash(\"Connection to server has been established\", 'success')\n            st_txt = \"connected\"\n            st_label = self.get_label(\"success\")\n        else:\n            self._disconnected_once = True\n            st_txt = \"disconnected\"\n            st_label = self.get_label(\"danger\")\n\n        self.compile(\"#server-status-t\", \"#server-status\", **\n                     {\"status\": st_txt, \"label\": st_label})\n\n    def on_error(self, msg):\n        self.flash(msg['error'], 'danger')\n\n    __pragma__('tconv')\n    __pragma__('iconv')\n\n    def on_server_call(self, msg):\n        \"Calls the designated callback.\"\n        if self._response_cb:\n            serv_msg = self._response_cb.pop(msg['id'])\n            serv_data = msg['msg']\n            self.session = serv_data['session']\n            if 'error' in serv_data:\n                self.flash_error(serv_data['error'])\n                if serv_data['error']['code'] == 408:\n                    self.send_command(self.commands['handshake'])\n            if serv_msg.func_name and serv_data:\n                for func in serv_data.data:\n                    err = None\n                    if 'error' in func:\n                        err = func['error']\n                        self.flash_error(err)\n                    if func['fname'] == serv_msg.func_name:\n                        if serv_msg.callback:\n                            serv_msg.callback(func['data'], err)\n                        break\n            else:\n                if serv_msg.callback:\n                    serv_msg.callback(serv_data)\n    __pragma__('noiconv')\n    __pragma__('notconv')\n\n    __pragma__('kwargs')\n\n    def call_func(self, func_name, callback, **kwargs):\n        \"Call function on server. Calls callback with function data and error\"\n        f_dict = {\n            'fname': func_name\n        }\n        f_dict.update(kwargs)\n        self.call(ServerMsg([f_dict], callback, func_name))\n    __pragma__('nokwargs')\n\n    def call(self, servermsg):\n        \"Send data to server. Calls callback with received data.\"\n        assert isinstance(servermsg, ServerMsg)\n        self._response_cb[servermsg.id] = servermsg\n        final_msg = {\n            'id': servermsg.id,\n            'msg': {\n                'session': self.session,\n                'name': self.name,\n                'data': servermsg.data\n            }\n        }\n\n        self._last_msg = final_msg\n        if self._connection_status:\n            self.socket.emit(\"server_call\", final_msg)\n        else:\n            self._msg_queue.append(final_msg)\n\nclient = Client()\nthumbclient = Client(namespace=\"/thumb\", new=True)\ncommandclient = Client(namespace=\"/command\", new=True)\n\nclass Command(Base):\n\n    def __init__(self, command_ids, customclient=None):\n        super().__init__()\n        assert command_ids is not None\n        self._single_id = None\n        if isinstance(command_ids, int):\n            self._single_id = command_ids\n            command_ids = [command_ids]\n\n        self._command_ids = command_ids\n        self._states = {}\n        self._values = {}\n        self._value_callback = None\n        self._getting_value = False\n        self.commandclient = commandclient\n\n        for i in self._command_ids:\n            self._states[str(i)] = None\n            self._values[str(i)] = None\n\n        if customclient:\n            self.commandclient = customclient\n\n    __pragma__('iconv')\n\n    def _check_status(self, data=None, error=None):\n        if data is not None and not error:\n            states = []\n            for i in self._command_ids:\n                str_i = str(i)\n                self._states[str_i] = data[str_i]\n        elif error:\n            pass\n        else:\n            self.commandclient.call_func(\"get_command_state\", self._check_status, command_ids=self._command_ids)\n    __pragma__('noiconv')\n\n    __pragma__('iconv')\n\n    def finished(self):\n        \"Check if command has finished running\"\n        states = []\n        for s in self._states:\n            states.append(self._states[s] in ['finished', 'stopped', 'failed'])\n        return all(states)\n    __pragma__('noiconv')\n\n    def poll_until_complete(self, interval=1000 * 5, timeout=1000 * 60 * 10, callback=None):\n        \"Keep polling for command state until it has finished running\"\n        if not self.finished():\n\n            def _poll():\n                if not self.finished():\n                    self._check_status()\n                else:\n                    self._fetch_value()\n                    if callback:\n                        callback()\n                return self.finished()\n\n            utils.poll_func(_poll, timeout, interval)\n\n    __pragma__('iconv')\n\n    def _fetch_value(self, data=None, error=None, cmd_ids=None):\n        if data is not None and not error:\n\n            for i in self._command_ids:\n                str_i = str(i)\n                if str_i in data:\n                    self._values[str_i] = data[str_i]\n\n            if self._value_callback:\n                self._value_callback(self)\n            self._getting_value = False\n        elif error:\n            pass\n        else:\n            if not self._getting_value:\n                if not cmd_ids:\n                    cmd_ids = self._command_ids\n                self.commandclient.call_func(\"get_command_value\", self._fetch_value, command_ids=cmd_ids)\n                self._getting_value = True\n    __pragma__('noiconv')\n\n    __pragma__('iconv')\n    __pragma__('tconv')\n\n    def get_value(self, cmd_id=None):\n        \"Fetch command value\"\n\n        if cmd_id and not isinstance(cmd_id, list):\n            cmd_id = [str(cmd_id)]\n\n        if not cmd_id:\n            cmd_id = self._command_ids\n\n        ids = []\n        for i in cmd_id:\n            if not self._values[i]:\n                ids.append(int(i))\n\n        if ids:\n            self._fetch_value(cmd_ids=ids)\n\n        if self._single_id:\n            return self._values[str(self._single_id)]\n        return self._values\n    __pragma__('noiconv')\n    __pragma__('notconv')\n\n    def set_callback(self, callback):\n        \"\"\"\n        Set a callback for when the value has been obtained\n        The callback is called with this command\n        \"\"\"\n        self._value_callback = callback\n"
	],
	"mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwWA;AAtWA;AAEA;AAGA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AAOA;AAAA;AAEA;AASA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAEA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAGA;AACA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAIA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAGA;AACA;AACA;AAEA;AAGA;AACA;AASA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAGA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAIA;AAEA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAEA;AAEA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}